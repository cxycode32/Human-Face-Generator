import os
import torch
import torch.nn as nn
import shutil
import random
import imageio
import torchvision
from torchvision.utils import save_image
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import truncnorm
import config


def clear_directories():
    """Helper function to clear directories."""
    for directory in config.DIRECTORIES:
        if os.path.exists(directory):
            shutil.rmtree(directory)
            print(f"{directory}/ deleted successfully!")


def save_checkpoint(type, epoch, model, optimizer, dir=config.MODEL_DIR):
    """
    Saves the model checkpoint to resume training from the same state.

    Args:
        type (str): The type of model to save.
        epoch (int): The current epoch, used to name the checkpoint.
        model (torch.nn.Module): The model to save.
        optimizer (torch.optim.Optimizer): The optimizer to save states.
        dir (str, optional): Directory to store the checkpoint. Defaults to config.MODEL_DIR.
    """
    print("Saving checkpoint......")

    os.makedirs(dir, exist_ok=True)
    checkpoint = {
        "state_dict": model.state_dict(),
        "optimizer": optimizer.state_dict(),
    }
    filepath = f"{dir}/{type}_{epoch}.pth"
    torch.save(checkpoint, filepath)

    print("Checkpoint saved successfully.")


def load_checkpoint(type, epoch, model, optimizer, dir=config.MODEL_DIR, learning_rate=config.LEARNING_RATE):
    """
    Loads a model checkpoint if available.

    Args:
        type (str): The type of model to load.
        epoch (int): Load the model from which epoch.
        model (torch.nn.Module): The model to load the checkpoint into.
        optimizer (torch.optim.Optimizer): The optimizer to restore states from the checkpoint.
        dir (str, optional): Directory where the checkpoint is stored. Defaults to config.MODEL_DIR.
        learning_rate (float, optional): Learning rate to be set after loading the optimizer state. Defaults to config.LEARNING_RATE.
    """
    if not os.path.exists(dir):
        print(f"Warning: Model directory '{dir}' does not exist. Falling back without loading checkpoint.")
        return

    checkpoint_path = os.path.join(dir, f"{type}_{epoch}.pth")

    if not os.path.isfile(checkpoint_path):
        print(f"Warning: Checkpoint file '{checkpoint_path}' not found. Falling back without loading checkpoint.")
        return

    print("Loading checkpoint......")

    checkpoint = torch.load(checkpoint_path, map_location="cuda")
    model.load_state_dict(checkpoint["state_dict"])
    optimizer.load_state_dict(checkpoint["optimizer"])

    for param_group in optimizer.param_groups:
        param_group["lr"] = learning_rate

    print("Checkpoint loaded successfully.")


def plot_losses(epoch, critic_losses, gen_losses, dir=config.ASSETS_DIR, filename="gan_loss"):
    """Helper function to visualize critic losses and generator losses.

    Args:
        disc_losses (list): Critic losses.
        gen_losses (list): Generator losses.
        dir (str, optional): Directory to save the image.
        filename (str, optional): Filename of the image.
    """
    plt.figure(figsize=(10, 5))
    plt.plot(critic_losses, label="Critic Loss")
    plt.plot(gen_losses, label="Generator Loss")
    plt.xlabel("Epoch")
    plt.ylabel("Loss")
    plt.legend()
    plt.title("GAN Training Loss")

    os.makedirs(dir, exist_ok=True)
    plt.savefig(f"{dir}/{filename}_{epoch}.png")

    plt.show()


def plot_to_tensorboard(writer, critic_loss, gen_loss, real, fake, tensorboard_step):
    """Helper function to plot critic losses and generator losses to TensorBoard.

    Args:
        disc_losses (list): Critic losses.
        gen_losses (list): Generator losses.
    """
    writer.add_scalar("Critic Loss", critic_loss, global_step=tensorboard_step)
    writer.add_scalar("Generator Loss", gen_loss, global_step=tensorboard_step)

    with torch.no_grad():
        img_grid_real = torchvision.utils.make_grid(real[:32], normalize=True)
        img_grid_fake = torchvision.utils.make_grid(fake[:32], normalize=True)
        writer.add_image("Real", img_grid_real, global_step=tensorboard_step)
        writer.add_image("Fake", img_grid_fake, global_step=tensorboard_step)


def save_fake_images(subdir, generator, alpha, step, epoch, dir=config.IMAGE_DIR, fixed_noise=config.FIXED_NOISE):
    """Helper function to save fake images generated by the generator.

    Args:
        subdir (str): Sub-directory to save the generated images (typically the epoch_num).
        generator (Generator): The generator model responsible for creating fake images.
        alpha (float): The current alpha value controlling fade-in during progressive training.
        step (int): The current step in progressive training.
        epoch (int): The current epoch during training, used to differentiate saved images.
        dir (str, optional): Main directory to save the generated images. Defaults to config.IMAGE_DIR.
        fixed_noise (Tensor, optional): A tensor of fixed random noise to generate images at specific epochs.
    """
    save_path = os.path.join(dir, subdir)
    os.makedirs(save_path, exist_ok=True)

    with torch.no_grad():
        fake = generator(fixed_noise, alpha, step)
        img_grid = torchvision.utils.make_grid(fake, normalize=True)
        image_path = os.path.join(save_path, f"epoch_{epoch}.png")
        torchvision.utils.save_image(img_grid, image_path)


def create_gif(epoch, assets_dir=config.ASSETS_DIR, image_dir=config.IMAGE_DIR, filename="gan_training"):
    """Creates a GIF from generated images stored in a directory.

    Args:
        epoch (str): Sub-directory name (typically epoch_num) containing saved images.
        assets_dir (str, optional): Directory where the GIF should be saved. Defaults to config.ASSETS_DIR.
        image_dir (str, optional): Directory where images are stored. Defaults to config.IMAGE_DIR.
        filename (str, optional): The base name for the GIF file. Defaults to "gan_training".
    """
    save_path = os.path.join(image_dir, epoch)

    if not os.path.exists(save_path):
        print(f"Warning: Image directory {save_path} does not exist. Skipping GIF creation.")
        return

    os.makedirs(assets_dir, exist_ok=True)

    images = sorted([os.path.join(save_path, f) for f in os.listdir(save_path) if f.endswith(".png")])

    if not images:
        print(f"Warning: No images found in {save_path} to create GIF.")
        return

    gif_images = [imageio.imread(img) for img in images]
    gif_path = os.path.join(assets_dir, f"{filename}_{epoch}.gif")
    imageio.mimsave(gif_path, gif_images, fps=5)
    print(f"GIF saved at: {gif_path}")


def gradient_penalty(critic, real, fake, alpha, train_step, device="cpu"):
    BATCH_SIZE, C, H, W = real.shape
    beta = torch.rand((BATCH_SIZE, 1, 1, 1)).repeat(1, C, H, W).to(device)
    interpolated_images = real * beta + fake.detach() * (1 - beta)
    interpolated_images.requires_grad_(True)

    # Calculate critic scores
    mixed_scores = critic(interpolated_images, alpha, train_step)

    # Take the gradient of the scores with respect to the images
    gradient = torch.autograd.grad(
        inputs=interpolated_images,
        outputs=mixed_scores,
        grad_outputs=torch.ones_like(mixed_scores),
        create_graph=True,
        retain_graph=True,
    )[0]
    gradient = gradient.view(gradient.shape[0], -1)
    gradient_norm = gradient.norm(2, dim=1)
    gradient_penalty = torch.mean((gradient_norm - 1) ** 2)
    return gradient_penalty


def seed_everything(seed=42):
    os.environ['PYTHONHASHSEED'] = str(seed)
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False


def generate_examples(gen, steps, truncation=0.7, n=100):
    """
    Tried using truncation trick here but not sure it actually helped anything, you can
    remove it if you like and just sample from torch.randn
    """
    gen.eval()
    alpha = 1.0
    for i in range(n):
        with torch.no_grad():
            noise = torch.tensor(truncnorm.rvs(-truncation, truncation, size=(1, config.Z_DIM, 1, 1)),
                                 device=config.DEVICE, dtype=torch.float32)
            img = gen(noise, alpha, steps)
            save_image(img * 0.5 + 0.5, f"saved_examples/img_{i}.png")
    gen.train()